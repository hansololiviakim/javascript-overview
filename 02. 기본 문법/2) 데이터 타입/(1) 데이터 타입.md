# 1. 데이터 타입

## 1.1 데이터 타입

### 데이터 타입

- 데이터 타입(data type, 타입)은 값의 종류를 말함

- **자바스크립트의 모든 값은 데이터 타입을 가지며, ES6 기준으로 7개의 데이터 타입 제공**

- 7개의 데이터 타입은 `원시 타입(primitive type)`과 `객체 타입(object/reference type)`으로 분류

<br/>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>데이터 타입</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody align="center">
    <tr>
      <td rowspan="6">원시 타입</td>
      <td>Number</td>
      <td>숫자, 정수/실수 구분 없이 하나의 숫자 타입만 존재</td>
    </tr>
    <tr>
      <td>String</td>
      <td>문자열</td>
    </tr>
    <tr>
      <td>Boolean</td>
      <td>논리적 참(true)과 거짓(false)</td>
    </tr>
    <tr>
      <td>Undefined</td>
      <td>var 키워드로 선언된 변수에 암묵적으로 할당되는 값</td>
    </tr>
    <tr>
      <td>Null</td>
      <td>값이 없다는 것을 의도적으로 명시할 때 사용되는 값</td>
    </tr>
    <tr>
      <td>Symbol</td>
      <td>ES6에서 추가된 7번째 타입</td>
    </tr>
    <tr>
      <td>객체 타입</td>
      <td colspan="2">Array, Function, Date, RegEx, Map & WeakMap, Set & WeakSet, ...</td>
    </tr>
  </tbody>
</table>

<br/>

### 데이터 타입의 구분

- 기본형과 참조형의 구분 기준은 `값의 저장 방식` 및 `불변성 여부`

<br/>

<table>
  <thead>
    <tr>
      <th></th>
      <th>원시 타입<br/>(primitive type)</th>
      <th>객체 타입<br/>(object/reference type)</th>
    </tr>
  </thead>
  <tbody align="center">
    <tr>
      <th>변경 가능 여부</th>
      <td>변경 불가능한 값 (immutable value)</td>
      <td>변경 가능한 값 (mutable value)</td>
    </tr>
    <tr>
      <th>변수에 할당 시<br/>(확보된 메모리 공간)</th>
      <td>실제 값 저장</td>
      <td>참조 값 저장</td>
    </tr>
    <tr>
      <th>다른 변수에 할당 시</th>
      <td>원시 값 복사되어 전달<br/>👉 값에 의한 전달 (pass by value)</td>
      <td>참조 값 복사되어 전달<br/>👉 참조에 의한 전달 (pass by reference)</td>
    </tr>
  </tbody>
</table>

<br/><br/>

## 1.2 숫자 타입

```javascript
// 모두 숫자 타입이다.
var integer = 10; // 정수
var double = 10.12; // 실수
var negative = -20; // 음의 정수

var binary = 0b01000001; // 2진수
var octal = 0o101; // 8진수
var hex = 0x41; // 16진수

// 표기법만 다를 뿐 모두 같은 값이다.
console.log(binary); // 65
console.log(octal); // 65
console.log(hex); // 65
console.log(binary === octal); // true
console.log(octal === hex); // true
```

- 자바스크립트는 하나의 숫자 타입만 존재

- 모든 수를 실수로 처리하며, 정수만 표현하기 위한 데이터 타입(integer type)이 별도로 존재하지 않음 <br/>
  👉 따라서 정수로 표시되는 수끼리 나누더라도 실수가 나올 수 있음

- 2, 8, 16진수를 표현하기 위한 데이터 타입 또한 제공하지 않기 때문에 이들 값을 참조하면 모두 10진수로 해석됨

<br/>

```javascript
// 숫자 타입의 세 가지 특별한 값
console.log(10 / 0); // Infinity
console.log(10 / -0); // -Infinity
console.log(1 * 'String'); // NaN
```

- 추가적으로 세 가지 특별한 값도 표현 가능

  - Infinity : 양의 무한대

  * -Infinity : 음의 무한대

  - NaN(Not of Number) : 산술 연산 불가

- 자바스크립트는 대소문자를 구별하므로 NaN을 NAN, nan, Nan 등으로 표기 시 에러 발생

<br/><br/>

## 1.3 문자열 타입

```javascript
// 문자열 타입
var string;
string = '문자열'; // 작은따옴표
string = '문자열'; // 큰따옴표
string = `문자열`; // 백틱 (ES6)

string = '작은따옴표로 감싼 문자열 내의 "큰따옴표"는 문자열로 인식된다.';
string = "큰따옴표로 감싼 문자열 내의 '작은따옴표'는 문자열로 인식된다.";
```

- 문자열 타입은 텍스트 데이터를 나타내는 데 사용하며, 0개 이상의 UTF-16의 집합으로 대부분의 문자 표현 가능

- `작은따옴표('')`, `큰따옴표("")`, 또는 ` 백틱(``) `으로 텍스트를 감쌈 <br/>
  👉 키워드나 식별자 같은 토큰과 구분하기 위함

- 따옴표로 문자열을 감싸지 않는다면 스페이스와 같은 공백 문자 포함 불가

- 문자열은 원시 타입이며 불변성이 있으므로 문자열 생성 시 문자열을 변경할 수 없음

<br/><br/>

## 1.4 템플릿 리터럴

- `ES6`부터 도입된 새로운 문자열 표기법

- 멀티라인 문자열, 표현식 삽입, 태그드 템플릿 등 편리한 문자열 처리 기능 제공

- `런타임에 일반 문자열로 변환되어 처리됨`

- 일반적인 따옴표 대신 백틱(``)을 사용해 표현

<br/>

### 1.4.1 멀티라인 문자열

```javascript
var template = `<ul>
  <li><a href="#">Home</a></li>
</ul>`;

console.log(template);

// 출력 결과
<ul>
  <li>
    <a href='#'>Home</a>
  </li>
</ul>;
```

- 일반 문자열 내에서는 줄바꿈(개행)이 허용되지 않음

- 따라서 줄바꿈 등의 공백을 표현하려면 백슬래시(\)로 시작하는 이스케이프 시퀀스를 사용해야 함

- **템플릿 리터럴 내에서는 이스케이프 시퀀스를 사용하지 않고도 줄 바꿈이 허용되며, 모든 공백도 그대로 적용됨**

<br/>

<details>
  <summary><b>[참고] 이스케이프 시퀀스</b></summary>

<table>
  <thead>
    <tr>
      <th>이스케이프 시퀀스</th>
      <th>의미</th>
    </tr>
  </thead>
  <tbody align="center">
    <tr>
      <td>\0</td>
      <td>Null</td>
    </tr>
    <tr>
      <td>\b</td>
      <td>백스페이스</td>
    </tr>
    <tr>
      <td>\f</td>
      <td>폼 피드(Form Feed)<br/>: 프린터로 출력 시 다음 페이지의 시작 지점으로 이동</td>
    </tr>
    <tr>
      <td>\n</td>
      <td>개행(Line Feed) : 다음 행으로 이동</td>
    </tr>
    <tr>
      <td>\r</td>
      <td>개행(Carriage Return) : 커서를 처음으로 이동</td>
    </tr>
    <tr>
      <td>\t</td>
      <td>탭(수평)</td>
    </tr>
    <tr>
      <td>\v</td>
      <td>탭(수직)</td>
    </tr>
    <tr>
      <td>\uXXXX</td>
      <td>유니코드 <i>(ex. \u0041 은 'A')</i></td>
    </tr>
    <tr>
      <td>\'</td>
      <td>작은따옴표</td>
    </tr>
    <tr>
      <td>\"</td>
      <td>큰따옴표</td>
    </tr>
    <tr>
      <td>\\</td>
      <td>백슬래시</td>
    </tr>
  </tbody>
</table>

<br/>

</details>

<br/>

<details>
  <summary><b>[참고] 라인 피드(LF)와 캐리지 리턴(CR)</b></summary>

- 개행(newline) 문자는 텍스트의 한 줄이 끝남을 표시하는 문자 또는 문자열

- 라인 피드(\n)는 타자기를 기준으로 했을 때 커서를 정지한 상태에서 종이를 한 줄 올리는 것

- 캐리지 리턴(\r)은 타자기를 기준으로 했을 때 종이를 움직이지 않고 커서를 맨 앞줄로 이동하는 것

- 윈도우는 CRLF(\r\n)로 새 줄을 나타내고, 유닉스는 LF, macOS 버전 10부터는 LF로 새 줄을 나타냄 <br/>
  👉 따라서 다른 운영체제에서 작성한 텍스트 파일은 서로 개행 문자를 인식하지 못함

- **자바스크립트에서 LF와 CR은 모두 개행을 의미하지만 CR로 개행하는 경우는 거의 없고, 일반적으로 LF로 개행**

<br/>

</details>

<br/>

### 1.4.2 표현식 삽입

```javascript
var first = 'Ung-mo';
var last = 'Lee';

// ES5: 문자열 연산자를 이용한 기존의 문자열 연결 방식
console.log('My name is ' + first + ' ' + last + '.'); // My name is Ung-mo Lee.

// ES6: 템플릿 리터럴 내 표현식 삽입을 이용한 문자열 연결 방식
console.log(`My name is ${first} ${last}.`); // My name is Ung-mo Lee.

// 문자열로 강제 형변환되어 삽입됨
console.log(`1 + 2 = ${1 + 2}`); // 1 + 2 = 3
```

- 템플릿 리터럴 미사용 시 문자열 연산자 + 를 사용해 문자열 연결

- 템플릿 리터럴 내에서는 표현식 삽입을 통해 간단히 문자열 삽입 가능

- 표현식을 삽입하려면 `${ }`로 표현식을 감싸는데, 표현식의 평가 결과가 문자열이 아니더라도 `문자열로 타입 강제 변환`되어 삽입됨

- 이때 표현식 삽입은 반드시 템플릿 리터럴 내에서 사용해야 함 _(일반 문자열에서의 표현식 삽입은 문자열로 취급됨)_

<br/><br/>

## 1.5 불리언 타입

```javascript
var foo = true;
console.log(foo); // true

foo = false;
console.log(foo); // false
```

- 불리언 타입의 값은 논리적 참, 거짓을 나타내는 `true`와 `false` 두 개만 존재

- 참과 거짓으로 구분되는 조건에 의해 프로그램의 흐름을 제어하는 조건문에서 자주 사용

<br/><br/>

## 1.6 undefined 타입

```javascript
var foo;
console.log(foo); // undefined
```

- undefined의 값은 undefined가 유일

- var 키워드로 선언한 변수는 처음 할당이 이뤄질 때까지 쓰레기 값(garbage value)으로 내버려 두지 않고 undefined로 초기화함

  - 따라서 **변수를 선언한 이후 값을 할당하지 않은 변수를 참조하면 undefined 반환**

  - 즉, 변수 참조 시 undefined가 반환된다면 참조한 변수 초기화되지 않은 변수라는 것을 알아낼 수 있음

- 자바스크립트 엔진이 변수를 초기화하는 데 사용하는 undefined를 개발자가 의도적으로 변수에 할당하면 본래 취지와 어긋날뿐더러 혼란을 줄 수 있으므로 권장하지 않음

  - **변수에 값이 없다는 것을 명시하고 싶을 때는 undefined가 아닌 `null` 할당 권장**

<br/><br/>

## 1.7 null 타입

- null 타입의 값은 null이 유일하며, 자바스크립트 엔진은 대소문자를 구별하므로 null은 Null, NULL과는 다름

- 프로그래밍 언어에서 null은 변수에 값이 없다는 것을 의도적으로 명시(`의도적 부재`)할 때 사용

- 변수에 null을 할당하는 것은 변수의 이전 참조 값을 더 이상 참조하지 않겠다는 것을 의미 <br/>
  👉 **즉, 이전에 할당되어 있던 값에 대한 참조를 명시적으로 제거하는 것**

<br/>

```javascript
<!DOCTYPE html>
<html>
  <body>
    <script>
      var element = document.querySelector('.myClass');

      // HTML 문서에 myClass 클래스를 갖는 요소가 없다면 null을 반환한다.
      console.log(element); // null
    </script>
  </body>
</html>
```

- 함수가 유효한 값을 반환할 수 없는 경우 명시적으로 null을 반환하기도 함

<br/><br/>

## 1.8 심벌 타입

```javascript
// 심벌 값 생성
var key = Symbol('key');
console.log(typeof key); // symbol

// 객체 생성
var obj = {};

// 이름이 충돌할 위험이 없는 유일무이한 값인 심벌을 프로퍼티 키로 사용한다.
obj[key] = 'value';
console.log(obj[key]); // value
```

- `ES6`에서 추가된 7번째 타입으로, `변경 불가능`한 원시 타입의 값이며 다른 값과 중복되지 않는 `유일무이한 값`

- 따라서 이름이` 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용`

- 심벌 이외의 원시 값은 리터럴을 통해 생성하나 심벌은 Symbol 함수를 호출해 생성

- 이때 생성된 심벌값은 `외부에 노출되지 않으며`, 다른 값과 절대 중복되지 않는 유일무이한 값임

<br/><br/>

## 1.9 객체 타입

- 자바스크립트는 `객체 기반`의 언어

- **지금까지 살펴본 6가지 데이터 타입 이외의 값은 모두 객체 타입**

<br/><br/>

## 1.10 데이터 타입의 필요성

### 1.10.1 데이터 타입에 의한 메모리 공간의 확보와 참조

- 자바스크립트 엔진은 데이터 타입(값의 종류)에 따라 정해진 크기의 메모리 공간 확보

- **변수에 할당되는 값의 데이터 타입에 따라 확보해야 할 메모리 공간의 크기가 결정됨**

<br/>

```javascript
var score = 100;
```

- 위의 예제에서 값을 참조하려면 메모리 셀의 개수(바이트 수 ≒ 한 번에 읽어 들여야 할 메모리 공간의 크기)를 알아야 함

- 숫자 타입의 값이 할당되어 있으므로 자바스크립트 엔진은 score 변수를 숫자 타입으로 인식

- score 변수를 참조하면 8바이트 단위로 메모리 공간에 저장된 값을 읽어 들임

<br/>

<details>
  <summary><b>[참고] 심볼 테이블(Symbol Table)</b></summary>

- 컴파일러 또는 인터프리터는 심볼 테이블이라고 불리는 자료 구조를 통해 **식별자를 키로 바인딩된 값의 메모리 주소, 데이터 타입, 스코프 등을 관리**

- 심볼 테이블은 **key, value의 쌍을 저장하는 데이터 구조이며, 특히 key를 검색어로 주었을 때 이에 대응하는 value를 빠르게 찾아주는 구조임**

- 다양한 애플리케이션에서 심볼 테이플을 필요로 하므로 대부분의 프로그래밍 언어에서 심볼 테이블 클래스를 기본 제공

- 언어에 따라 이를 `dictionary` 또는 `map`이라고 함

- 심볼 테이블에서의 key는 `unique` 해야 함 _(그래야만 찾고자 하는 value 데이터를 특정할 수 있기 때문)_

</details>

<br/>

### 1.10.2 데이터 타입에 의한 값의 해석

- 모든 값은 데이터 타입을 가지며, 메모리에 2진수(비트의 나열)로 저장됨

- 이때 **메모리에 저장된 값은 데이터 타입에 따라 다르게 해석될 수 있음** <br/>
  👉 _ex. 메모리에 저장된 값 0100 0001을 숫자로 해석하면 65지만, 문자열로 해석하면 'A'_

- 6.9.1의 예제의 socre 변수에 할당된 값은 숫자 타입의 값이므로, score 변수를 참조하면 메모리 공간의 주소에서 읽어 들인 2진수를 숫자로 해석함

<br/>

### 1.10.3 결론

따라서 데이터 타입이 필요한 이유는 아래와 같음

- 값을 저장할 때 `확보해야 하는 메모리 공간의 크기를 결정`하기 위해

- 값을 참조할 때 한 번에 `읽어 들여야 할 메모리 공간의 크기를 결정`하기 위해

- 메모리에서 읽어 들인 `2진수를 어떻게 해석할지 결정`하기 위해

<br/><br/>

## 1.11 동적 타이핑

### 1.11.1 정적 타입 언어

- 정적 타입(static/strong type) 언어는 변수를 선언할 때 변수에 할당할 수 있는 값의 종류, 즉 `데이터 타입을 사전에 선언`해야 함

- 이를 `명시적 타입 선언`이라 함

- 정적 타입 언어는 변수의 타입을 변경할 수 없으며, 선언한 타입에 맞는 값만 할당 가능

- 컴파일 시점에 타입 체크(선언한 데이터 타입에 맞는 값을 할당했는지 검사하는 처리)를 수행

- 이를 통해 타입의 일관성을 강제함으로써 더욱 안정적인 코드의 구현을 통해 런타임 시 발생하는 에러를 줄임

- _C, C++, Java, Kotiln, Go, Haskell, Rust, Scala, ..._

<br/>

### 1.11.2 동적 타입 언어

- 변수 선언 시 타입을 선언하지 않음

- 자바스크립트는 var, let, const 키워드를 사용해 변수를 선언하기만 함

- **어떠한 데이터 타입의 값이라도 자유롭게 할당 가능**

- 변수의 선언이 아닌 할당에 의해 타입이 결정(`타입 추론`)되며, **재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있음**

- 이를 `동적 타이핑`이라 하며, 자바스크립트를 정적 타입 언어와 구별하기 위해 `동적 타입 언어`라 함

- _JavaScript, Python, PHP, Ruby, Lisp, Perl, ..._

- ⚠️ 참고로 변수는 타입을 갖지 않지만 `값은 타입을 가짐`!

<br/>

### 1.11.3 정적 타입 언어와 동적 타입 언어의 비교

<table>
  <thead>
    <tr>
      <th></th>
      <th>정적 타입 언어<br/>(Statically typed languages)</th>
      <th>동적 타입 언어<br/>(Dynamically typed languages)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>특징</th>
      <td>
        ＊ 컴파일 시 변수의 타입이 결정되는 언어 <br/>
        ＊ 따라서 프로그래머가 변수에 들어갈 값의 형태에 따라 직접 변수의 타입을 명시해줘야 함 <br/>
        ＊ 컴파일 시 자료형에 맞지 않는 값이 들어있으면 에러 발생
      </td>
      <td>
        ＊ 런타임 시 자료형 결정
      </td>
    </tr>
    <tr>
      <th>장점</th>
      <td>
        ＊ 타입 에러로 인한 문제점을 초기에 발견할 수 있어 타입의 안정성이 높음 <br/>
        ＊ 컴파일 시 미리 타입을 결정하기 때문에 실행 속도가 빠름
      </td>
      <td>
        ＊ 런타임까지 타입에 대한 결정을 끌고 갈 수 있기 떄문에 유연성이 높음 <br/>
        ＊ 컴파일 시 타입을 명시해주지 않아도 되기 떄문에 빠르게 코드를 작성할 수 있음
      </td>
    </tr>
    <tr>
      <th>단점</th>
      <td>
        ＊ 매번 코드 작성 시 변수형을 결정해줘야 하는 번거로움이 있음
      </td>
      <td>
        ＊ 실행 도중 변수에 예상치 못한 타입이 들어와 타입 에러가 발생할 수 있음
      </td>
    </tr>
  </tbody>
</table>

<br/>

### 1.11.4 동적 타입 언어의 구조적 단점

- 변수 값은 언제든지 변경될 수 있기 때문에 복잡한 프로그램에서는 변화하는 변수 값을 추적하기 어려울 수 있음

- 동적 타입 언어의 변수는 값의 변경에 의해 타입도 언제든지 변경될 수 있음

- 따라서 **동적 타입 언어의 변수는 값을 확인하기 전에는 타입을 확신할 수 없음**

- 결국 동적 타입 언어는 `유연성(flexibility)은 높지만 신뢰성(reliability)은 떨어짐`

<br/>

### 1.11.5 변수 사용 시 주의 사항

- 변수는 꼭 필요한 경우에 한해 제한적으로 사용해야 함 <br/>
  👉 변수의 개수가 많아질수록 오류가 발생할 확률도 높아지므로, 변수의 무분별한 남발은 금물이며 필요한 만큼 최소한으로 유지

- 변수의 유효 범위(스코프)는 최대한 좁게 만들어 변수의 부작용을 억제해야 함

- 전역 변수는 최대한 지양

- 변수보다는 상수를 사용해 값의 변경을 억제해야 함 (const)

- 변수 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍해야 함

<br/>

### etc.

- 코드는 오해하지 않도록 작성해야 함

- 가독성이 좋은 코드가 좋은 코드

<br/>

    ✨  컴퓨터가 이해하는 코드는 어떤 바보도 쓸 수 있다.
        하지만 훌륭한 프로그래머는 사람이 이해할 수 있는 코드를 쓴다.

        - 마틴 파울러
